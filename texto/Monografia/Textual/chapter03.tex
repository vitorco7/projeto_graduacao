\chapter{Metodologia Proposta}
\label{chap3}

{\color{red}
No capítulo anterior, foram apresentados os conceitos e as tecnologias relevantes para a compreensão da solução de monitoramento desenvolvida. Contudo, vale ressaltar que nem todas as ferramentas descritas anteriormente foram efetivamente empregadas na implementação final da proposta.

Este capítulo tem por objetivo detalhar todo o processo de desenvolvimento da solução de monitoramento, desde as primeiras considerações e escolhas de arquitetura, passando pela seleção e adaptação das ferramentas adotadas, até a apresentação da solução final implementada. Serão discutidas as motivações para determinadas decisões técnicas, desafios encontrados ao longo do desenvolvimento, e os métodos empregados para contorná-los, buscando sempre respaldar as opções feitas com base nos conceitos apresentados no Capítulo 2.

Também são descritos os equipamentos utilizados durante o desenvolvimento. Foram utilizados dois computadores, cujas especificações são apresentadas na Tabela \ref{tab:available-hardware}.


\begin{table}[H]
\centering
{\color{red}
\caption{Especificações de hardware dos equipamentos disponíveis}
\label{tab:available-hardware}
\begin{tabular}{lcc}
\toprule
\textbf{Componente} & \textbf{Desktop} & \textbf{Notebook} \\
\midrule
CPU   & Intel Core i5-7600   & Intel Core i7-8565U \\
RAM   & 16GB                 & 32GB                \\
Disco & 500GB (SSD)            & 250GB (SSD)          \\
\bottomrule
\end{tabular}
}
\end{table}

As especificações do sistema operacional serão apresentadas posteriormente, visto que a escolha desse aspecto evoluiu ao longo do desenvolvimento, conforme será detalhado neste capítulo.

\section{Abordagem Preliminar}
\label{section:AbordagemPreliminar}

Esta seção apresenta uma visão geral das decisões iniciais tomadas antes da definição da arquitetura final da solução de monitoramento. As primeiras etapas deste trabalho podem ser divididas em dois momentos: inicialmente, o escopo era voltado para o monitoramento de infraestruturas de TI tradicionais (como servidores e clusters); em seguida, evoluiu para englobar também dispositivos conectados à rede de forma abrangente, sem restrições de tipagem.

\subsection{Escopo inicial - Infraestrutura Tradicional}
\label{subsection:EscopoInicial}

Durante as discussões preliminares, o objetivo era monitorar servidores. Foi considerada uma arquitetura onde um dispositivo --podendo ser um NUC ou Raspberry Pi com softwares instalados-- realizaria a coleta de métricas deste servidor e, após o processamento destes dados, disponibilizaria-os em painés com visualizações gráficas especializadas. Alternativas com Orange Pi como equipamento foram analisadas, mas a escolha final recaiu sobre o NUC ou Raspberry Pi devido à suas respectivas popularidades e suporte.

Entretanto, como não foi possível adquirir fisicamente um NUC ou Raspberry Pi, decidiu-se simular toda a \foreign{stack} de monitoramento em uma máquina virtual. Com isso, a possibilidade da utilização de distribuições ou versões do Raspberry Pi OS para fins de desenvolvimento foi descartada, por tratar-se de um sistema operacional baseado em arquitetura ARM, incompatível com a arquitetura x86-64 dos equipamentos disponíveis.

No desktop disponível, à época com sistema operacional não-Linux, instalou-se o VMWare Workstation Player para configuração de uma VM com Rocky Linux. A escolha pelo Rocky Linux baseou-se em sua compatibilidade com o CentOS, estabilidade e longo ciclo de suporte, características valorizadas em ambientes corporativos.

No entanto, o VMWare Workstation Player mostrou-se limitado em recursos, dificultando a execução de múltiplas VMs. Por isso, migrou-se para o VirtualBox, o que trouxe maior flexibilidade e controle.

Esta estratégia inicial apresentou limitações importantes: a primeira era a maior dificuldade na aquisição de dados, pois seria necessário obter um servidor físico para coleta dos mesmos. Outra limitação seria elevado custo computacional inerente ao uso de VMs em comparação a soluções baseadas em contêineres, e pouca modularidade, resultando em manutenção complexa e baixa praticidade.

Devido a esses fatores, verificou-se a necessidade de reavaliar o escopo e buscar abordagens mais aderentes aos recursos disponíveis e aos objetivos do projeto.

\begin{figure}[H]
\centering
\fbox{\rule{0pt}{150pt} \rule{200pt}{0pt}} % 200pt wide, 150pt high
\caption{Inserir aqui uma imagem esquemática da arquitetura inicial}
\label{fig:placeholder}
\end{figure}

-----
****Inserir aqui uma imagem esquemática da arquitetura inicial****
-----

\subsection{Escopo Reformulado - Monitoramento Amplo}
\label{subsection:EscopoReformulado}

Até então, os sistemas operacionais dos \foreign{hosts} disponíveis eram distintos (o desktop com um sistema não-Linux e o notebook com Ubuntu Desktop). Considerando as limitações encontradas na abordagem inicial, optou-se por instalar o Ubuntu Server no desktop como SO\abbrev{SO}{Sistema Operacional} para experimentação.

Conforme relatado na literatura, o Ubuntu Server demonstrou desempenho satisfatório e baixo consumo de recursos. Contudo, visando padronizar os ambientes de desenvolvimento, decidiu-se por padronizar o Ubuntu Desktop em ambos os dispositivos: versão 24.04 no desktop e 20.04 no notebook.

No decorrer dessas alterações, a abordagem de monitoramento foi ampliada para contemplar não apenas servidores, mas também uma ampla variedade de dispositivos conectados à rede. Essa redefinição proporcionou maior versatilidade ao projeto, tornando desnecessária a aquisição de servidores físicos e possibilitando a utilização de contêineres tanto para a simulação de dispositivos quanto para a implementação da stack de monitoramento. Com isso, o processo de desenvolvimento tornou-se mais prático, ágil e modular, além de permitir um aproveitamento mais eficiente dos recursos computacionais disponíveis. Cabe destacar ainda que, ao adotar contêineres não só para testes, mas também para toda a infraestrutura de monitoramento, a discussão sobre a necessidade de hardware específico, como NUC ou Raspberry Pi, perdeu relevância neste contexto, já que a solução desenvolvida pode ser executada em qualquer máquina compatível com tecnologias de conteinerização.

%TODO: Em trabalhos futuros a análise de viabilidade de implementação em NUC ou Raspberry Pi

\begin{figure}[H]
\centering
\fbox{\rule{0pt}{150pt} \rule{200pt}{0pt}} % 200pt wide, 150pt high
\caption{Inserir aqui uma imagem esquemática da arquitetura reformulada}
\label{fig:placeholder}
\end{figure}

-----
****Inserir aqui uma imagem esquemática da arquitetura reformulada****
-----


\subsection{Das versões iniciais}
\label{subsection:VersõesIniciais}

% A virtualização desempenha um papel essencial neste trabalho por dois motivos principais. Primeiramente, conforme discutido na Seção \ref{section:Delimitação}, a indisponibilidade de equipamentos motivou a adoção de técnicas de virtualização para simular diferentes dispositivos, permitindo a criação de um ambiente de testes controlado e replicável utilizando uma úniac máquina física como base. 

% Em segundo lugar, a conteinerização dos softwares de monitoramento e coleta de métricas contribui diretamente para a portabilidade, escalabilidade, automação e manutenção da solução desenvolvida. Ao encapsular os serviços em contêineres independentes, é possível garantir maior uniformidade entre ambientes de desenvolvimento e produção, além de alinhar a implementação aos princípios da IaC.

A virtualização desempenha um papel essencial neste trabalho. Além dos benefícios já mencionados, a conteinerização utilizando orquestradores como Docker Compose permite o versionamento de todo o trabalho desenvolvido em repositórios de controle de versão, como o Git. Esta abordagem rege todo o trabalho a seguir.

Desde o início do projeto, o Zabbix foi escolhido como principal ferramenta de monitoramento. Mesmo após a reformulação do escopo, o Zabbix permaneceu como a solução central, devido à sua capacidade de atender todos os requisitos do projeto: possui interface web, é de código aberto, é amplamente utilizado e consolidado no mercado, sendo compatível com diversos sistemas operacionais, arquiteturas e possuindo ampla documentação e ferramentas como agentes, proxies e servidores. Além disso, o Zabbix é altamente escalável, permitindo a adição de novos dispositivos e serviços monitorados de forma simples e eficiente.

Tendo o Zabbix como motor central, posteriormente acoplaria-se a ele o Grafana. Apesar do Zabbix já possuir uma interface web com \foreign{dashboards} e gráficos, o Grafana oferece uma experiência de visualização mais rica e personalizável, sendo um complemento ideal.


{\color{blue}
-----RASCUNHO-----

A partir do repositório de Dockerfiles do Zabbix \citep{zabbixdocker2025}, foi feito um fork para o repositório do projeto. Com isso, experimentou-se com os recursos da ferramenta, subindo um servidor Zabbix, um banco de dados MySQL e um agente em contêineres Docker. Por já incluir um modelo de \foreign{dashboard} no Dockerfile, o servidor Zabbix foi inicializado com um \foreign{dashboard} básico.


- Falar o que eu fiz com o zabbix (pontos a serem abordados na seção 3.1.3. Finalizando esta subseção, eu finalizo as abordagens preliminares e vou para a descrição do projeto):
    \begin{itemize}
        \item subi os containers
        \item instalei um agente nao oficial no meu celular
        \item consegui pingar o meu celular a partir do container do servidor
        \item consegui vincular o container do agente ao servidor
        \item acabei nao gostando da interface e navegabilidade
        \item dificuldade realizar configurações avançadas via interface web
        \item os arquivos do projeto do Zabbix são muito inchados e extensos, o que dificultou a leitura e compreensão do código por ter características monolíticas, o Zabbix estava difícil de compreender e manter.
        \item É mais custoso computacionalmente (precisa de um banco de dados acoplado como o MySQL ou Postgres)
        \item unindo a curva de aprendizado do Docker com a do Zabbix, somado aos itens acima, foi custoso, o que me fez trocar pro Prometheus 
    
    \end{itemize}
     
    !!!DÚVIDAS COM RELAÇÃO À ESTRUTURA DO TEXTO!!!

    Até então, estou escrevendo o cap3 seguindo uma linha temporal de eventos, enquanto descrevo a Metodologia e ao mesmo tempo realizo as Discussões para explicar as decisões de projeto. Tenho 3 formas de seguir com o capítulo:
    
    \begin{enumerate}
        \item Eu escrevo o capítulo todo descrevendo a Metodologia ao mesmo tempo que realizo as Discussões para justificar as decisões;
        \item Eu reformulo tudo o que foi escrito no cap 3 até aqui, focando APENAS na Metodologia (ou seja, descrevendo objetivamente o que foi, de fato, feito) e, posteriormente, num capítulo 4, eu apresento as Discussões;
        \item Eu deixo a seção 3.1 como está, finalizo a 3.1.3 com os pontos apresentados no rascunho, e nas seções seguintes do capítulo 3 eu descrevo APENAS a Metodologia, deixando discussões de projeto para um capítulo 4 - Discussões?



    \end{enumerate}

     
     
     
     
     


}
}
\section{Descrição Macro da Arquitetura da Solução}

Placeholder

\section{Infraestrutura}

Placeholder

\section{Discussão sobre as métricas}

Placeholder

\section{Aplicação de Monitoramento}

Placeholder
